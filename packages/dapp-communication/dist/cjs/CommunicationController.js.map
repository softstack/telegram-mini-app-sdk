{"version":3,"file":"CommunicationController.js","sourceRoot":"","sources":["../../src/CommunicationController.ts"],"names":[],"mappings":"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","sourcesContent":["import { CallbackController, parse, stringify, TypedEvent } from '@tconnect.io/core';\nimport { io, Socket } from 'socket.io-client';\nimport {\n\tCommunicationControllerEvents,\n\tSerializedCommunicationController,\n\tWrappedRequest,\n\tWrappedResponse,\n} from './types';\nimport { validateWrappedResponse } from './validation';\n\nexport class CommunicationController<Request, Response, Event> extends TypedEvent<\n\tCommunicationControllerEvents<Event>\n> {\n\tconstructor(bridgeUrl: string, path: string, requestChannel: string, eventChannel: string) {\n\t\tsuper();\n\t\tthis.bridgeUrl = bridgeUrl;\n\t\tthis.path = path;\n\t\tthis.requestChannel = requestChannel;\n\t\tthis.eventChannel = eventChannel;\n\t}\n\n\treadonly bridgeUrl: string;\n\treadonly path: string;\n\treadonly requestChannel: string;\n\treadonly eventChannel: string;\n\n\tprivate _socket: Socket | undefined;\n\tprivate _requestCallbacks = new CallbackController<Response>(1000 * 60);\n\n\tasync connect(): Promise<void> {\n\t\tif (this._socket) {\n\t\t\tthis.disconnect();\n\t\t}\n\t\tthis._socket = io(this.bridgeUrl, {\n\t\t\tpath: this.path,\n\t\t\ttransports: ['polling'], // Use long polling only\n\t\t});\n\n\t\tthis._socket.on('error', (error) => {\n\t\t\ttry {\n\t\t\t\tthis.emit('error', error);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\n\t\tthis._socket.on(this.requestChannel, (wrappedResponse) => {\n\t\t\ttry {\n\t\t\t\tlet validatedWrappedResponse: WrappedResponse<Response>;\n\t\t\t\ttry {\n\t\t\t\t\tvalidatedWrappedResponse = validateWrappedResponse(wrappedResponse);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Invalid response wrapper', error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._requestCallbacks.resolveCallback(validatedWrappedResponse.requestId, validatedWrappedResponse.response);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\n\t\tthis._socket.on(this.eventChannel, (event) => {\n\t\t\ttry {\n\t\t\t\tthis.emit('event', event);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\n\t\treturn new Promise<void>((resolve) => {\n\t\t\ttry {\n\t\t\t\tthis._socket?.once('connect', () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\t}\n\n\tconnected(): boolean {\n\t\treturn !!this._socket?.connected;\n\t}\n\n\tsend(request: Request): Promise<Response> {\n\t\tif (!this._socket) {\n\t\t\tthrow new Error(\"Can't send request without connection\");\n\t\t}\n\t\tconst wrappedRequest: WrappedRequest<Request> = {\n\t\t\trequestId: crypto.randomUUID(),\n\t\t\trequest: request,\n\t\t};\n\t\tconst callbackPromise = this._requestCallbacks.addCallback(wrappedRequest.requestId);\n\t\tthis._socket?.emit(this.requestChannel, wrappedRequest);\n\t\treturn callbackPromise;\n\t}\n\n\tdisconnect(): void {\n\t\tif (this._socket) {\n\t\t\tthis._socket.removeAllListeners();\n\t\t\tthis._socket.disconnect();\n\t\t\tthis._socket = undefined;\n\t\t}\n\t}\n\n\tserialize(): string {\n\t\treturn stringify({\n\t\t\tbridgeUrl: this.bridgeUrl,\n\t\t\tpath: this.path,\n\t\t\trequestChannel: this.requestChannel,\n\t\t\teventChannel: this.eventChannel,\n\t\t} satisfies SerializedCommunicationController);\n\t}\n\n\tstatic deserialize<Request, Response, Event>(serialized: string): CommunicationController<Request, Response, Event> {\n\t\tconst { bridgeUrl, path, requestChannel, eventChannel } = parse(serialized) as SerializedCommunicationController;\n\t\treturn new CommunicationController<Request, Response, Event>(bridgeUrl, path, requestChannel, eventChannel);\n\t}\n}\n"]}