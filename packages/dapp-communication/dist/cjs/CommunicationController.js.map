{"version":3,"file":"CommunicationController.js","sourceRoot":"","sources":["../../src/CommunicationController.ts"],"names":[],"mappings":"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","sourcesContent":["import { CallbackController, parse, stringify, TypedEvent } from '@tconnect.io/core';\nimport { io, Socket } from 'socket.io-client';\nimport {\n\tCommunicationControllerEvents,\n\tSerializedCommunicationController,\n\tWrappedRequest,\n\tWrappedResponse,\n} from './types';\nimport { validateWrappedResponse } from './validation';\n\n/**\n * The `CommunicationController` class is responsible for managing communication\n * between a client and a server using a socket connection. It handles sending\n * requests, receiving responses, and emitting events.\n *\n * @template Request - The type of the request object.\n * @template Response - The type of the response object.\n * @template Event - The type of the event object.\n *\n * @extends TypedEvent<CommunicationControllerEvents<Event>>\n */\nexport class CommunicationController<Request, Response, Event> extends TypedEvent<\n\tCommunicationControllerEvents<Event>\n> {\n\t/**\n\t * Creates an instance of CommunicationController.\n\t *\n\t * @param bridgeUrl - The URL of the bridge server.\n\t * @param path - The path for the communication endpoint.\n\t * @param requestChannel - The channel used for sending requests.\n\t * @param eventChannel - The channel used for receiving events.\n\t */\n\tconstructor(bridgeUrl: string, path: string, requestChannel: string, eventChannel: string) {\n\t\tsuper();\n\t\tthis.bridgeUrl = bridgeUrl;\n\t\tthis.path = path;\n\t\tthis.requestChannel = requestChannel;\n\t\tthis.eventChannel = eventChannel;\n\t}\n\n\t/**\n\t * The URL of the bridge server used for communication.\n\t * This URL is used to establish a connection between the dApp and the bridge server.\n\t *\n\t * @readonly\n\t */\n\treadonly bridgeUrl: string;\n\t/**\n\t * The path to the resource or endpoint that this controller communicates with.\n\t */\n\treadonly path: string;\n\t/**\n\t * The channel used for sending requests.\n\t * This is a read-only property that specifies the communication channel\n\t * through which requests are sent.\n\t */\n\treadonly requestChannel: string;\n\t/**\n\t * The channel through which events are communicated.\n\t */\n\treadonly eventChannel: string;\n\n\t/**\n\t * A private member variable that holds the instance of the Socket.\n\t * It is used to manage the WebSocket connection for communication.\n\t * This variable can be undefined if the socket is not initialized.\n\t *\n\t * @private\n\t */\n\tprivate _socket: Socket | undefined;\n\t/**\n\t * A private instance of CallbackController that manages request callbacks.\n\t * It is initialized with a timeout of 60 seconds (1000 milliseconds * 60).\n\t *\n\t * @private\n\t */\n\tprivate _requestCallbacks = new CallbackController<Response>(1000 * 60);\n\n\t/**\n\t * Establishes a connection to the bridge server using a socket.\n\t * If a socket connection already exists, it will be disconnected first.\n\t *\n\t * @returns {Promise<void>} A promise that resolves when the connection is successfully established.\n\t *\n\t * @throws {Error} If an error occurs during the connection process.\n\t *\n\t * @remarks\n\t * - The socket uses long polling as the transport method.\n\t * - Listens for 'error' events and emits them.\n\t * - Listens for responses on the request channel, validates them, and resolves the corresponding callbacks.\n\t * - Listens for events on the event channel and emits them.\n\t *\n\t * @example\n\t * ```typescript\n\t * const controller = new CommunicationController();\n\t * controller.connect().then(() => {\n\t *   console.log('Connected successfully');\n\t * }).catch((error) => {\n\t *   console.error('Connection failed', error);\n\t * });\n\t * ```\n\t */\n\tasync connect(): Promise<void> {\n\t\tif (this._socket) {\n\t\t\tthis.disconnect();\n\t\t}\n\t\tthis._socket = io(this.bridgeUrl, {\n\t\t\tpath: this.path,\n\t\t\ttransports: ['polling'], // Use long polling only\n\t\t});\n\n\t\tthis._socket.on('error', (error) => {\n\t\t\ttry {\n\t\t\t\tthis.emit('error', error);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\n\t\tthis._socket.on(this.requestChannel, (wrappedResponse) => {\n\t\t\ttry {\n\t\t\t\tlet validatedWrappedResponse: WrappedResponse<Response>;\n\t\t\t\ttry {\n\t\t\t\t\tvalidatedWrappedResponse = validateWrappedResponse(wrappedResponse);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Invalid response wrapper', error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._requestCallbacks.resolveCallback(validatedWrappedResponse.requestId, validatedWrappedResponse.response);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\n\t\tthis._socket.on(this.eventChannel, (event) => {\n\t\t\ttry {\n\t\t\t\tthis.emit('event', event);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\n\t\treturn new Promise<void>((resolve) => {\n\t\t\ttry {\n\t\t\t\tthis._socket?.once('connect', () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if the communication controller is connected.\n\t *\n\t * @returns {boolean} `true` if the socket is connected, otherwise `false`.\n\t */\n\tconnected(): boolean {\n\t\treturn !!this._socket?.connected;\n\t}\n\n\t/**\n\t * Sends a request through the established socket connection.\n\t *\n\t * @param request - The request object to be sent.\n\t * @returns A promise that resolves to the response of the request.\n\t * @throws Will throw an error if there is no active socket connection.\n\t */\n\tsend(request: Request): Promise<Response> {\n\t\tif (!this._socket) {\n\t\t\tthrow new Error(\"Can't send request without connection\");\n\t\t}\n\t\tconst wrappedRequest: WrappedRequest<Request> = {\n\t\t\trequestId: crypto.randomUUID(),\n\t\t\trequest: request,\n\t\t};\n\t\tconst callbackPromise = this._requestCallbacks.addCallback(wrappedRequest.requestId);\n\t\tthis._socket?.emit(this.requestChannel, wrappedRequest);\n\t\treturn callbackPromise;\n\t}\n\n\t/**\n\t * Disconnects the current socket connection if it exists.\n\t * This method will remove all listeners from the socket and then disconnect it.\n\t * After disconnecting, the socket will be set to undefined.\n\t */\n\tdisconnect(): void {\n\t\tif (this._socket) {\n\t\t\tthis._socket.removeAllListeners();\n\t\t\tthis._socket.disconnect();\n\t\t\tthis._socket = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Serializes the current state of the CommunicationController instance into a JSON string.\n\t *\n\t * @returns {string} A JSON string representing the serialized state of the CommunicationController.\n\t */\n\tserialize(): string {\n\t\treturn stringify({\n\t\t\tbridgeUrl: this.bridgeUrl,\n\t\t\tpath: this.path,\n\t\t\trequestChannel: this.requestChannel,\n\t\t\teventChannel: this.eventChannel,\n\t\t} satisfies SerializedCommunicationController);\n\t}\n\n\t/**\n\t * Deserializes a JSON string into a `CommunicationController` instance.\n\t *\n\t * @template Request - The type of the request.\n\t * @template Response - The type of the response.\n\t * @template Event - The type of the event.\n\t * @param {string} json - The JSON string to deserialize.\n\t * @returns {CommunicationController<Request, Response, Event>} - The deserialized `CommunicationController` instance.\n\t */\n\tstatic deserialize<Request, Response, Event>(json: string): CommunicationController<Request, Response, Event> {\n\t\tconst { bridgeUrl, path, requestChannel, eventChannel } = parse(json) as SerializedCommunicationController;\n\t\treturn new CommunicationController<Request, Response, Event>(bridgeUrl, path, requestChannel, eventChannel);\n\t}\n}\n"]}