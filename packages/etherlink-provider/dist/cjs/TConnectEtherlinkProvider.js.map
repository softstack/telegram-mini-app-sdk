{"version":3,"file":"TConnectEtherlinkProvider.js","sourceRoot":"","sources":["../../src/TConnectEtherlinkProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import { parse, sleep, stringify, TypedEvent } from '@tconnect.io/core';\nimport { CommunicationController } from '@tconnect.io/dapp-communication';\nimport { getErrorMessage, isAndroid, openLink } from '@tconnect.io/dapp-utils';\nimport {\n\tEtherlinkConnectedRequest,\n\tEtherlinkConnectedResponse,\n\tEtherlinkConnectRequest,\n\tEtherlinkConnectResponse,\n\tEtherlinkDisconnectRequest,\n\tEtherlinkDisconnectResponse,\n\tEtherlinkError,\n\tEtherlinkEvent,\n\tEtherlinkNetwork,\n\tEtherlinkReconnectRequest,\n\tEtherlinkReconnectResponse,\n\tEtherlinkRequest,\n\tEtherlinkRequestRequest,\n\tEtherlinkRequestResponse,\n\tEtherlinkResponse,\n\tEVENT_CHANNEL,\n\tREQUEST_CHANNEL,\n\tSOCKET_IO_PATH,\n} from '@tconnect.io/etherlink-api-types';\nimport { ProviderRpcError } from './ProviderRpcError';\nimport {\n\tEIP1193Provider,\n\tEtherlinkWalletApp,\n\tRequestArguments,\n\tSerializedTConnectEtherlinkProvider,\n\tTConnectEtherlinkProviderEvents,\n\tTConnectEtherlinkProviderOptions,\n} from './types';\nimport { getConnectionStringUniversalLink, getUniversalLink } from './utils';\nimport { validateEtherlinkEvent, validateEtherlinkResponse } from './validation';\n\n/**\n * The TConnectEtherlinkProvider class provides an implementation of the EIP-1193 provider interface\n * for connecting to the Etherlink blockchain via a bridge URL and a wallet application.\n * It extends the TypedEvent class to handle various events related to the connection and requests.\n *\n * @extends TypedEvent<TConnectEtherlinkProviderEvents>\n * @implements {EIP1193Provider}\n */\nexport class TConnectEtherlinkProvider extends TypedEvent<TConnectEtherlinkProviderEvents> implements EIP1193Provider {\n\tconstructor(options: TConnectEtherlinkProviderOptions) {\n\t\tsuper();\n\t\tthis.appName = options.appName;\n\t\tthis.appUrl = options.appUrl;\n\t\tthis.appIcon = options.appIcon;\n\t\tthis.bridgeUrl = options.bridgeUrl;\n\t\tthis.walletApp = options?.walletApp;\n\t\tthis.network = options.network;\n\t\tthis._apiKey = options.apiKey;\n\t\tthis._communicationController = new CommunicationController(\n\t\t\tthis.bridgeUrl,\n\t\t\tSOCKET_IO_PATH,\n\t\t\tREQUEST_CHANNEL,\n\t\t\tEVENT_CHANNEL,\n\t\t);\n\t}\n\n\t/**\n\t * The name of the application.\n\t * This property is read-only and is used to identify the application.\n\t */\n\treadonly appName: string;\n\t/**\n\t * The URL of the application that is using the Etherlink provider.\n\t * This is a read-only property.\n\t */\n\treadonly appUrl: string;\n\treadonly appIcon: string | undefined;\n\t/**\n\t * The URL of the bridge service that the provider will use to communicate with the Etherlink network.\n\t * This URL is required to establish a connection and perform operations on the Etherlink network.\n\t */\n\treadonly bridgeUrl: string;\n\t/**\n\t * The wallet application instance for interacting with the Etherlink.\n\t * This property is read-only and may be undefined if the wallet application is not initialized.\n\t */\n\treadonly walletApp: EtherlinkWalletApp | undefined;\n\n\treadonly network: EtherlinkNetwork;\n\n\t/**\n\t * The API key used for authentication with the Etherlink provider.\n\t *\n\t * @private\n\t */\n\tprivate readonly _apiKey: string;\n\t/**\n\t * A private instance of CommunicationController used to handle communication\n\t * between the Etherlink provider and the external environment. It processes Etherlink requests,\n\t * responses, and events.\n\t *\n\t * @private\n\t */\n\tprivate _communicationController: CommunicationController<EtherlinkRequest, EtherlinkResponse, EtherlinkEvent>;\n\t/**\n\t * A unique identifier for the current session.\n\t * This identifier is used to track and manage the session state.\n\t * It can be undefined if no session is currently active.\n\t *\n\t * @private\n\t */\n\tprivate _sessionId: string | undefined;\n\t/**\n\t * The URI used to establish a connection with a WalletConnect session.\n\t * This property may be undefined if the URI has not been set.\n\t *\n\t * @private\n\t */\n\tprivate _connectionString: string | undefined;\n\n\t/**\n\t * Establishes a connection with the Etherlink provider.\n\t *\n\t * If already connected, it will first disconnect before attempting to reconnect.\n\t * Once connected, it sets up an event handler for communication events.\n\t *\n\t * The method sends a request to establish a connection using the provided API key.\n\t * Upon successful connection, it retrieves the session ID and WalletConnect URI.\n\t *\n\t * If a wallet application is specified, it attempts to open the WalletConnect link.\n\t * For Android devices, it sends the link twice with a delay to ensure it opens.\n\t *\n\t * Finally, it emits the connection string (WalletConnect URI) for further use.\n\t *\n\t * @returns {Promise<void>} A promise that resolves when the connection process is complete.\n\t */\n\tasync connect(): Promise<void> {\n\t\tif (this._communicationController.connected()) {\n\t\t\tawait this.disconnect();\n\t\t}\n\t\tawait this._communicationController.connect();\n\n\t\tconst connectionStringEventHandler = async (event: EtherlinkEvent): Promise<void> => {\n\t\t\ttry {\n\t\t\t\tconst validatedEvent = validateEtherlinkEvent(event);\n\t\t\t\tif (validatedEvent.type === 'connectionString') {\n\t\t\t\t\tthis._communicationController.off('event', connectionStringEventHandler);\n\t\t\t\t\tconst { connectionString } = validatedEvent.payload;\n\t\t\t\t\tthis._connectionString = connectionString;\n\t\t\t\t\tif (this.walletApp) {\n\t\t\t\t\t\t// Android needs a second reminder to open the link\n\t\t\t\t\t\tif (isAndroid()) {\n\t\t\t\t\t\t\topenLink(getConnectionStringUniversalLink(this.walletApp, connectionString), {\n\t\t\t\t\t\t\t\ttry_instant_view: true,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait sleep(1000);\n\t\t\t\t\t\t\topenLink(getConnectionStringUniversalLink(this.walletApp, connectionString), {\n\t\t\t\t\t\t\t\ttry_instant_view: true,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topenLink(getConnectionStringUniversalLink(this.walletApp, connectionString));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit('connectionString', connectionString);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t};\n\n\t\tthis._communicationController.on('event', connectionStringEventHandler);\n\t\tthis._communicationController.on('event', this._createEtherlinkEventHandler());\n\n\t\tconst {\n\t\t\tpayload: { sessionId },\n\t\t} = await this._sendEtherlinkRequest({\n\t\t\ttype: 'connect',\n\t\t\tpayload: {\n\t\t\t\tapiKey: this._apiKey,\n\t\t\t\tappName: this.appName,\n\t\t\t\tappUrl: this.appUrl,\n\t\t\t\tappIcon: this.appIcon,\n\t\t\t\tnetwork: this.network,\n\t\t\t},\n\t\t});\n\t\tthis._sessionId = sessionId;\n\t}\n\n\t/**\n\t * Checks if the provider is connected.\n\t *\n\t * This method verifies if there is an active session and if the communication controller is connected.\n\t * It then sends a request to check the connection status and returns the result.\n\t *\n\t * @returns {Promise<boolean>} A promise that resolves to `true` if connected, otherwise `false`.\n\t */\n\tasync connected(): Promise<boolean> {\n\t\tif (!this._sessionId || !this._communicationController.connected()) {\n\t\t\treturn false;\n\t\t}\n\t\tconst response = await this._sendEtherlinkRequest({\n\t\t\ttype: 'connected',\n\t\t\tsessionId: this._getSessionId(),\n\t\t});\n\t\treturn response.payload.connected;\n\t}\n\n\t/**\n\t * Handles Ethereum JSON-RPC requests and sends them to the communication controller.\n\t * If the wallet application is set, it opens a universal link for certain methods.\n\t *\n\t * @param {RequestArguments} args - The arguments for the JSON-RPC request.\n\t * @returns {Promise<unknown>} A promise that resolves with the response payload.\n\t *\n\t * @remarks\n\t * The method handles the following Ethereum JSON-RPC methods by opening a universal link:\n\t * - 'eth_sendTransaction'\n\t * - 'eth_sign'\n\t * - 'eth_signTransaction'\n\t * - 'eth_signTypedData'\n\t * - 'eth_signTypedData_v3'\n\t * - 'eth_signTypedData_v4'\n\t * - 'personal_sign'\n\t */\n\tasync request(args: RequestArguments): Promise<unknown> {\n\t\tif (this.walletApp) {\n\t\t\tswitch (args.method) {\n\t\t\t\tcase 'eth_sendTransaction':\n\t\t\t\tcase 'eth_sign':\n\t\t\t\tcase 'eth_signTransaction':\n\t\t\t\tcase 'eth_signTypedData':\n\t\t\t\tcase 'eth_signTypedData_v3':\n\t\t\t\tcase 'eth_signTypedData_v4':\n\t\t\t\tcase 'personal_sign': {\n\t\t\t\t\topenLink(getUniversalLink(this.walletApp));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst response = await this._sendEtherlinkRequest({\n\t\t\ttype: 'request',\n\t\t\tsessionId: this._getSessionId(),\n\t\t\tpayload: args,\n\t\t});\n\t\treturn response.payload;\n\t}\n\n\t/**\n\t * Disconnects the provider from the current session.\n\t *\n\t * This method sends a 'disconnect' message to the communication controller\n\t * and emits a 'disconnect' event with a `ProviderRpcError` indicating the\n\t * disconnection. It also ensures that the communication controller is\n\t * properly disconnected.\n\t *\n\t * @returns {Promise<void>} A promise that resolves when the disconnection process is complete.\n\t */\n\tasync disconnect(): Promise<void> {\n\t\ttry {\n\t\t\tawait this._communicationController.send({ type: 'disconnect', sessionId: this._getSessionId() });\n\t\t} finally {\n\t\t\tthis.emit('disconnect', new ProviderRpcError('Disconnected', 4900));\n\t\t\tthis._communicationController.disconnect();\n\t\t\tthis._communicationController.removeAllListeners();\n\t\t}\n\t}\n\n\t/**\n\t * Serializes the TConnectEtherlinkProvider instance into a JSON string.\n\t *\n\t * @returns {string} A JSON string representation of the TConnectEtherlinkProvider instance.\n\t */\n\tserialize(): string {\n\t\treturn stringify({\n\t\t\tappName: this.appName,\n\t\t\tappUrl: this.appUrl,\n\t\t\tappIcon: this.appIcon,\n\t\t\tbridgeUrl: this.bridgeUrl,\n\t\t\twalletApp: this.walletApp,\n\t\t\tnetwork: this.network,\n\t\t\t_apiKey: this._apiKey,\n\t\t\t_communicationController: this._communicationController.serialize(),\n\t\t\t_sessionId: this._getSessionId(),\n\t\t\t_connectionString: this._getConnectionString(),\n\t\t} satisfies SerializedTConnectEtherlinkProvider);\n\t}\n\n\t/**\n\t * Deserializes a JSON string into a `TConnectEtherlinkProvider` instance.\n\t *\n\t * @param json - The JSON string to deserialize.\n\t * @returns A promise that resolves to a `TConnectEtherlinkProvider` instance.\n\t */\n\tstatic async deserialize(json: string): Promise<TConnectEtherlinkProvider> {\n\t\tconst data = parse(json) as SerializedTConnectEtherlinkProvider;\n\t\tconst provider = new TConnectEtherlinkProvider({\n\t\t\tappName: data.appName,\n\t\t\tappUrl: data.appUrl,\n\t\t\tappIcon: data.appIcon,\n\t\t\tbridgeUrl: data.bridgeUrl,\n\t\t\tapiKey: data._apiKey,\n\t\t\twalletApp: data.walletApp,\n\t\t\tnetwork: data.network,\n\t\t});\n\t\tprovider._communicationController = CommunicationController.deserialize(data._communicationController);\n\t\tprovider._sessionId = data._sessionId;\n\t\tprovider._connectionString = data._connectionString;\n\t\tawait provider._reconnect();\n\t\treturn provider;\n\t}\n\n\t/**\n\t * Reconnects the Etherlink provider by setting up the event handler and sending a reconnect request.\n\t *\n\t * This method performs the following steps:\n\t * 1. Registers an event handler for communication events.\n\t * 2. Establishes a connection with the communication controller.\n\t * 3. Sends a reconnect request with the current session ID.\n\t *\n\t * @returns {Promise<void>} A promise that resolves when the reconnection process is complete.\n\t * @private\n\t */\n\tprivate async _reconnect(): Promise<void> {\n\t\tthis._communicationController.on('event', this._createEtherlinkEventHandler());\n\t\tawait this._communicationController.connect();\n\t\tawait this._sendEtherlinkRequest({ type: 'reconnect', sessionId: this._getSessionId() });\n\t}\n\n\t/**\n\t * Creates an event handler for Etherlink events.\n\t *\n\t * This handler validates incoming Etherlink events and emits corresponding events\n\t * based on the event type. The supported event types are:\n\t * - 'connect': Emitted when a connection is established.\n\t * - 'message': Emitted when a message is received.\n\t * - 'chainChanged': Emitted when the blockchain chain is changed.\n\t * - 'accountsChanged': Emitted when the accounts are changed.\n\t * - 'disconnect': Emitted when a disconnection occurs, with an error message, code, and data.\n\t *\n\t * If an error occurs during event validation or handling, it is logged to the console.\n\t *\n\t * @returns {Function} A function that handles Etherlink events.\n\t * @private\n\t */\n\tprivate _createEtherlinkEventHandler() {\n\t\treturn (event: EtherlinkEvent): void => {\n\t\t\ttry {\n\t\t\t\tconst validatedEvent = validateEtherlinkEvent(event);\n\t\t\t\tswitch (validatedEvent.type) {\n\t\t\t\t\tcase 'connect': {\n\t\t\t\t\t\tthis.emit('connect', validatedEvent.payload);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'message': {\n\t\t\t\t\t\tthis.emit('message', validatedEvent.payload);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'chainChanged': {\n\t\t\t\t\t\tthis.emit('chainChanged', validatedEvent.payload);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'accountsChanged': {\n\t\t\t\t\t\tthis.emit('accountsChanged', validatedEvent.payload);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'disconnect': {\n\t\t\t\t\t\tconst { message, code, data } = validatedEvent.payload;\n\t\t\t\t\t\tthis.emit('disconnect', new ProviderRpcError(message, code, data));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Sends an Etherlink request and returns the response after validation.\n\t *\n\t * @param etherlinkRequest - The Etherlink request to be sent.\n\t * @returns A promise that resolves to the Etherlink response.\n\t * @throws Will throw an error if there is no connection, if the response contains an error, or if the response type does not match the request type.\n\t * @private\n\t */\n\tprivate async _sendEtherlinkRequest(etherlinkRequest: EtherlinkConnectRequest): Promise<EtherlinkConnectResponse>;\n\tprivate async _sendEtherlinkRequest(etherlinkRequest: EtherlinkConnectedRequest): Promise<EtherlinkConnectedResponse>;\n\tprivate async _sendEtherlinkRequest(etherlinkRequest: EtherlinkRequestRequest): Promise<EtherlinkRequestResponse>;\n\tprivate async _sendEtherlinkRequest(etherlinkRequest: EtherlinkReconnectRequest): Promise<EtherlinkReconnectResponse>;\n\tprivate async _sendEtherlinkRequest(\n\t\tetherlinkRequest: EtherlinkDisconnectRequest,\n\t): Promise<EtherlinkDisconnectResponse>;\n\tprivate async _sendEtherlinkRequest(etherlinkRequest: EtherlinkRequest): Promise<EtherlinkResponse> {\n\t\tif (!this._communicationController.connected()) {\n\t\t\tthrow new Error(\"Can't send request without connection\");\n\t\t}\n\t\tconst etherlinkResponse = await this._communicationController.send(etherlinkRequest);\n\t\tconst validatedEtherlinkResponse = validateEtherlinkResponse(etherlinkResponse);\n\t\tif (validatedEtherlinkResponse.type === 'error') {\n\t\t\tif (validatedEtherlinkResponse.payload.type === 'generic') {\n\t\t\t\tlet errorMessage = `Error Code: ${validatedEtherlinkResponse.payload.key}`;\n\t\t\t\tif (validatedEtherlinkResponse.payload.message) {\n\t\t\t\t\terrorMessage += `: ${validatedEtherlinkResponse.payload.message}`;\n\t\t\t\t}\n\t\t\t\tthrow new Error(errorMessage);\n\t\t\t} else {\n\t\t\t\tthrow new EtherlinkError(\n\t\t\t\t\tvalidatedEtherlinkResponse.payload.type,\n\t\t\t\t\tgetErrorMessage(validatedEtherlinkResponse.payload.type, validatedEtherlinkResponse.payload.message),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (etherlinkRequest.type !== validatedEtherlinkResponse.type) {\n\t\t\tthrow new Error('Response type is different from request type');\n\t\t}\n\t\treturn etherlinkResponse;\n\t}\n\n\t/**\n\t * Retrieves the current session ID.\n\t *\n\t * @returns {string} The session ID.\n\t * @throws {Error} If the session ID is not set.\n\t * @private\n\t */\n\tprivate _getSessionId(): string {\n\t\tif (!this._sessionId) {\n\t\t\tthrow new Error('Session ID is not set');\n\t\t}\n\t\treturn this._sessionId;\n\t}\n\n\t/**\n\t * Retrieves the WalletConnect URI.\n\t *\n\t * @returns {string} The WalletConnect URI.\n\t * @throws {Error} If the WalletConnect URI is not set.\n\t * @private\n\t */\n\tprivate _getConnectionString(): string {\n\t\tif (!this._connectionString) {\n\t\t\tthrow new Error('Connection string is not set');\n\t\t}\n\t\treturn this._connectionString;\n\t}\n}\n"]}