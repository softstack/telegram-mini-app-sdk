{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,KAAK,IAAI,MAAM,EACf,SAAS,IAAI,UAAU,GAIvB,MAAM,4BAA4B,CAAC;AACpC,OAAO,GAAiC,MAAM,KAAK,CAAC;AAYpD,MAAM,CAAC,MAAM,cAAc,GAAG,CAAI,KAAQ,EAAE,MAAiB,EAAK,EAAE;IACnE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,cAAc,EAAE,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAChE,IAAI,KAAK,EAAE,CAAC;QACX,MAAM,KAAK,CAAC;IACb,CAAC;IACD,OAAO,cAAc,CAAC;AACvB,CAAC,CAAC;AASF,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,KAAc,EAAE,MAAc,EAAW,EAAE;IACvE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACzC,OAAO,CAAC,KAAK,CAAC;AACf,CAAC,CAAC;AAUF,MAAM,CAAC,MAAM,gBAAgB,GAAG,CAAI,KAAc,EAAE,MAAc,EAAc,EAAE,CAAC,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AAU/G,MAAM,CAAC,MAAM,YAAY,GAAG,CAAI,KAAc,EAAE,IAAoB,EAAc,EAAE;IACnF,MAAM,MAAM,GAAqB,EAAE,CAAC;IACpC,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACxB,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC;IACpC,CAAC;IACD,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC;IACpD,OAAO,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACpC,CAAC,CAAC;AAcF,MAAM,eAAe,GAAwC,CAAC,GAAG,EAAE,EAAE;IACpE,IAAI,GAAG,YAAY,MAAM,EAAE,CAAC;QAC3B,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;IAChF,CAAC;IACD,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;AAC7B,CAAC,CAAC;AAUF,MAAM,WAAW,GAAoC,CAAC,GAAG,EAAE,EAAE;IAC5D,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,GAAqC,CAAC;IACvD,QAAQ,CAAC,EAAE,CAAC;QACX,KAAK,QAAQ,CAAC,CAAC,CAAC;YACf,IAAI,CAAC,KAAK,SAAS,EAAE,CAAC;gBACrB,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC;YAC7B,CAAC;YACD,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE,CAAC;QAC9D,CAAC;IACF,CAAC;IACD,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;AAC7B,CAAC,CAAC;AAQF,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,GAAY,EAAU,EAAE;IACjD,OAAO,UAAU,CAAC,GAAG,EAAE,EAAE,eAAe,EAAE,CAAC,CAAC;AAC7C,CAAC,CAAC;AAQF,MAAM,CAAC,MAAM,KAAK,GAAG,CAAC,IAAY,EAAW,EAAE;IAC9C,OAAO,MAAM,CAAC,IAAI,EAAE,EAAE,WAAW,EAAE,CAAC,CAAC;AACtC,CAAC,CAAC","sourcesContent":["import {\n\tparse as _parse,\n\tstringify as _stringify,\n\tCustomParse,\n\tCustomStringify,\n\tTypedValue,\n} from '@softstack/typed-stringify';\nimport Joi, { PartialSchemaMap, Schema } from 'joi';\nimport { CustomStrigifyType } from './types';\n\n/**\n * Validates a given value against a specified schema.\n *\n * @template T - The type of the value to be validated.\n * @param {T} value - The value to be validated.\n * @param {Schema<T>} schema - The schema to validate the value against.\n * @returns {T} - The validated value.\n * @throws {Error} - Throws an error if the validation fails.\n */\nexport const validateSchema = <T>(value: T, schema: Schema<T>): T => {\n\tconst { error, value: validatedValue } = schema.validate(value);\n\tif (error) {\n\t\tthrow error;\n\t}\n\treturn validatedValue;\n};\n\n/**\n * Validates a value against a given schema.\n *\n * @param value - The value to be validated.\n * @param schema - The schema to validate the value against.\n * @returns `true` if the value is valid according to the schema, otherwise `false`.\n */\nexport const validateType = (value: unknown, schema: Schema): boolean => {\n\tconst { error } = schema.validate(value);\n\treturn !error;\n};\n\n/**\n * Validates the given value against the provided schema and asserts its type.\n *\n * @template T - The expected type of the value.\n * @param value - The value to be validated.\n * @param schema - The schema to validate the value against.\n * @returns A boolean indicating whether the value conforms to the schema and is of type T.\n */\nexport const validateGuardian = <T>(value: unknown, schema: Schema): value is T => validateType(value, schema);\n\n/**\n * Validates that the given value contains the specified keys.\n *\n * @template T - The type of the object to validate.\n * @param value - The value to validate.\n * @param keys - An array of keys that the value should contain.\n * @returns A boolean indicating whether the value contains the specified keys.\n */\nexport const validateKeys = <T>(value: unknown, keys: Array<keyof T>): value is T => {\n\tconst keyMap: PartialSchemaMap = {};\n\tfor (const key of keys) {\n\t\tkeyMap[key] = Joi.any().required();\n\t}\n\tconst schema = Joi.object().keys(keyMap).required();\n\treturn validateType(value, schema);\n};\n\n/**\n * Custom stringify function that handles specific object types.\n *\n * @template T - The type of the object to be stringified.\n * @param {T} obj - The object to be stringified.\n * @returns {CustomStringifyResult} - The result of the custom stringify operation.\n *\n * @example\n * const buffer = Buffer.from('example');\n * const result = customStringify(buffer);\n * // result: { useResult: true, result: { t: 'Buffer', v: 'ZXhhbXBsZQ==' } }\n */\nconst customStringify: CustomStringify<CustomStrigifyType> = (obj) => {\n\tif (obj instanceof Buffer) {\n\t\treturn { useResult: true, result: { t: 'Buffer', v: obj.toString('base64') } };\n\t}\n\treturn { useResult: false };\n};\n\n/**\n * Parses a given object and returns a result based on its type.\n *\n * @template CustomStrigifyType - The type of the value to be parsed.\n * @param {TypedValue<CustomStrigifyType>} obj - The object to be parsed, containing a type and a value.\n * @returns {{ useResult: boolean; result?: Buffer }} An object indicating whether a result was used and the parsed result if applicable.\n * @throws {Error} If the value is undefined for the 'Buffer' type.\n */\nconst customParse: CustomParse<CustomStrigifyType> = (obj) => {\n\tconst { t, v } = obj as TypedValue<CustomStrigifyType>;\n\tswitch (t) {\n\t\tcase 'Buffer': {\n\t\t\tif (v === undefined) {\n\t\t\t\tthrow new Error('No value');\n\t\t\t}\n\t\t\treturn { useResult: true, result: Buffer.from(v, 'base64') };\n\t\t}\n\t}\n\treturn { useResult: false };\n};\n\n/**\n * Converts an unknown object to a JSON string representation.\n *\n * @param obj - The object to be stringified.\n * @returns The JSON string representation of the object.\n */\nexport const stringify = (obj: unknown): string => {\n\treturn _stringify(obj, { customStringify });\n};\n\n/**\n * Parses a JSON string and returns the resulting object.\n *\n * @param json - The JSON string to parse.\n * @returns The parsed object.\n */\nexport const parse = (json: string): unknown => {\n\treturn _parse(json, { customParse });\n};\n"]}